'# RWMH using Dex

import plot

-- first some utils to read the data

def words (sep: Word8) (source: String): List String =
  (AsList _ s) = source <> (to_list [sep])
  (AsList num_words space_ixs) = cat_maybes for i_char.
    if (s.i_char == sep)
      then Just i_char
      else Nothing
  to_list for i_word:(Fin num_words).
    start = case prev_ix i_word of
      Nothing -> first_ix
      Just i -> right_post space_ixs.i
    end = left_post space_ixs.i_word
    post_slice s start end

def cons {a} (x: a) (xs: List a): List a =
  (AsList on xt) = xs
  n = on + 1
  nxt = for i:(Fin n). case (ordinal i == 0) of
    True -> x
    False -> xt.(asidx (unsafe_nat_diff (ordinal i) 1))
  to_list nxt

def list_to_tab {n a b} [Ix n] (dummyt: n=>b) (l: List a): n=>a =
  (AsList ll t) = l
  unsafe_cast_table n t

def parse_tsv_old {n a} [Ix n] (sep: Word8) (dummyt: n=>a) (input: String): List (n=>String) =
  (AsList _ lines) = lines input
  tab_list_words = map (words sep) lines
  to_list $ map (list_to_tab dummyt) tab_list_words

def parse_tsv (sep: Word8) (input: String): List (List String) =
  (AsList _ lines) = lines input
  to_list $ map (words sep) lines

-- now read and process the data

dat = unsafe_io do read_file "../pima.data"
(AsList _ tab) = parse_tsv ' ' dat
atab = map (cons "1.0") tab
att = map (list_to_tab (for i:(Fin 9). 1)) atab
xStr = map (\r. slice r 0 (Fin 8)) att
xmb = map (\r. map parseString r) xStr :: (Fin 200)=>(Fin 8)=>(Maybe Float)
x = map (\r. map from_just r) xmb :: (Fin 200)=>(Fin 8)=>Float
yStrM = map (\r. slice r 8 (Fin 1)) att
yStr = (transpose yStrM).(0@_)
y = map (\s. select (s == "Yes") 1.0 0.0) yStr

x
y

-- now set up for MCMC

def ll (b: (Fin 8)=>Float) : Float =
  neg $ sum (log (map (\ x. x+1) (exp (neg ((map (\ yi. 2*yi - 1) y)*(x **. b))))))

pscale = [10.0, 1, 1, 1, 1, 1, 1, 1] -- prior SDs
prscale = map (\ x. 1.0/x) pscale

def lprior (b: (Fin 8)=>Float) : Float =
  bs = b*prscale
  neg $ sum ((log pscale) + (0.5 .* (bs*bs)))

def lpost (b: (Fin 8)=>Float) : Float =
  (ll b) + (lprior b)

pre = [10.0,1,1,1,1,1,5,1] -- pre-conditioner - relative weights of proposal SDs

def rprop (k: Key) (b: (Fin 8)=>Float) : (Fin 8)=>Float =
  b + 0.02 .* (pre * (randn_vec k))

k = new_key 42

def mKernel {s} (lpost: s -> Float) (rprop: Key -> s -> s) : Key -> (s & Float) -> (s & Float) =
  def kern (k: Key) (sll: (s & Float)) : (s & Float) =
    (x0, ll0) = sll
    [k1, k2] = split_key k
    x = rprop k1 x0
    ll = lpost x
    a = ll - ll0
    u = rand k2
    select (log u < a) (x, ll) (x0, ll0)
  kern

def last {a n} [Ix n] (arr: n=>a): a =
  nind = unsafe_nat_diff (size n) 1
  arr.(asidx nind)

def step_n {s} (n: Nat) (kern: Key -> s -> s) : Key -> s -> s =
  def go (k: Key) (state: s) : s =
    xv = with_state state \st.
      for i:(Fin n).
        x = kern (ixkey k i) (get st)
        st := x
        x
    last xv
  go

kern = mKernel lpost rprop

def mcmc {s} (k: Key) (init: s) (kern: Key -> s -> s) (its: Nat) : Fin its => s =
  with_state init \st.
    for i:(Fin its).
      x = kern (ixkey k i) (get st)
      st := x
      x

init = [-9.0,0,0,0,0,0,0,0]

out = mcmc k (init, -1.0e50) (step_n 1000 kern) 10000

-- from Dex MCMC example file, mcmc.dx
def meanAndCovariance {n d} (xs:n=>d=>Float) : (d=>Float & d=>d=>Float) =
   xsMean :    d=>Float = (for i. sum for j. xs.j.i) / n_to_f (size n)
   xsCov  : d=>d=>Float = (for i i'. sum for j.
                           (xs.j.i' - xsMean.i') *
                           (xs.j.i  - xsMean.i )   ) / (n_to_f (size n) - 1)
   (xsMean, xsCov)

mat = map fst out -- ditch log-posterior evaluations
mv = meanAndCovariance mat
fst mv -- mean
snd mv -- (co)variance matrix

-- :html show_plot $ y_plot $
--   (map head mat)

def to_tsv {n p} (mat: n=>p=>Float) : String =
  ms = for i j. show mat.i.j <> "\t"
  concat (map (\l. l <> "\n") (map concat ms))

unsafe_io do write_file "fit-bayes.tsv" (to_tsv mat)


-- eof
