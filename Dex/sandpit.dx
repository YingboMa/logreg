-- sandpit.dx
-- just messing around...


-- a few useful functions, which should maybe be in the prelude

def iterate {a} (n: Nat) (step: a -> a) (init: a) : Fin n => a =
  with_state init \st.
    for i:(Fin n).
      old = get st
      next = step old
      st := next
      old

def unfold {a b} (n: Nat) (advance: a -> (b & a)) (init: a) : Fin n => b =
  with_state init \st.
    for i:(Fin n).
      (b, a) = advance (get st)
      st := a
      b

def length {a n} [Ix n] (arr: n=>a): Nat =
  size n

def last_dumb {a n} [Ix n] (arr: n=>a): a =
  head $ reverse arr

def last {a n} [Ix n] (arr: n=>a): a =
  nind = unsafe_nat_diff (size n) 1
  arr.(asidx nind)

def to_tsv {n p} (mat: n=>p=>Float) : String =
  ms = for i j. show mat.i.j <> "\t"
  concat (map (\l. l <> "\n") (map concat ms))

-- based on "lines" from the Prelude...
def words (sep: Word8) (source: String): List String =
  (AsList _ s) = source <> (to_list [sep])
  (AsList num_words space_ixs) = cat_maybes for i_char.
    if (s.i_char == sep)
      then Just i_char
      else Nothing
  to_list for i_word:(Fin num_words).
    start = case prev_ix i_word of
      Nothing -> first_ix
      Just i -> right_post space_ixs.i
    end = left_post space_ixs.i_word
    post_slice s start end

def cons {a} (x: a) (xs: List a): List a =
  (AsList on xt) = xs
  n = on + 1
  nxt = for i:(Fin n). case (ordinal i == 0) of
    True -> x
    False -> xt.(asidx (unsafe_nat_diff (ordinal i) 1))
  to_list nxt

def list_to_tab {n a b} [Ix n] (dummyt: n=>b) (l: List a): n=>a =
  (AsList ll t) = l
  unsafe_cast_table n t

def parse_tsv_old {n a} [Ix n] (sep: Word8) (dummyt: n=>a) (input: String): List (n=>String) =
  (AsList _ lines) = lines input
  tab_list_words = map (words sep) lines
  to_list $ map (list_to_tab dummyt) tab_list_words

def parse_tsv (sep: Word8) (input: String): List (List String) =
  (AsList _ lines) = lines input
  to_list $ map (words sep) lines

-- examples

dat = unsafe_io do read_file "../pima.data"
(AsList _ tab) = parse_tsv ' ' dat
atab = map (cons "1.0") tab
att = map (list_to_tab (for i:(Fin 9). 1)) atab
xStr = map (\r. slice r 0 (Fin 8)) att
xmb = map (\r. map parseString r) xStr :: (Fin 200)=>(Fin 8)=>(Maybe Float)
x = map (\r. map from_just r) xmb :: (Fin 200)=>(Fin 8)=>Float
yStrM = map (\r. slice r 8 (Fin 1)) att
yStr = (transpose yStrM).(0@_)
y = map (\s. select (s == "Yes") 1.0 0.0) yStr
x
y



iterate 10 (\x. x*2) 1

unfold 10 (\a. (show a, a+1)) 0

last_dumb [1.0,2,3,6]
last [1.0,2,3,7]
length [1.0, 2, 3]

m = [[1.0,2,3],[4.4,5,6]]
to_tsv m

v = [1.0,2,3,4]

cons 1.5 (to_list v)


-- eof
